PAGINA 14 van 18
     
     FIGUUR 3: OAUTH2 TOKEN REFRESH FLOW
     
     +-------------------------------------------------------------------------+
 40  |                   ADVANCED OAUTH2 TOKEN REFRESH ENGINE                  |
     +-------------------------------------------------------------------------+
     
     STEP 1: Initial Authentication
        User → Authorization Server → Auth Code → Access Token + Refresh Token
 45  
     STEP 2: Token Storage
        access_token: "eyJhbGciOiJSUzI1NiIs..."
        refresh_token: "def502000a1b2c3d4e5f..."
        expires_in: 3600 seconds
 50     token_expires: datetime.now() + timedelta(seconds=3600)
     
     STEP 3: Pre-emptive Refresh (5-minute buffer)
        if (token_expires - datetime.now()).total_seconds() < 300:
            POST /oauth2/token
 55         Body: {
                "grant_type": "refresh_token",
                "refresh_token": "{REFRESH_TOKEN}",
                "client_id": "{CLIENT_ID}",
                "client_secret": "{CLIENT_SECRET}"
 60         }
     
     STEP 4: Automatic Retry Logic
        401 Unauthorized → Refresh token + retry (max 3 attempts)
        429 Too Many Requests → Exponential backoff (1s, 2s, 4s, 8s)
 65     500-503 Errors → Linear backoff (5s, 10s, 15s)
     
     FIGUUR 4: ENTERPRISE RATE LIMITING SYSTEM
     
     +-------------------------------------------------------------------------+
 70  |              THREAD-SAFE ENTERPRISE RATE LIMITING                       |
     +-------------------------------------------------------------------------+
     
     RATE LIMITS BY CONNECTOR:
     
 75  Microsoft Graph API:
        ├─ Calls per minute: 10,000
        ├─ Calls per hour: 600,000
        └─ Per-second derived: 166.67
     
 80  Google Workspace API:
        ├─ Calls per minute: 1,000
        ├─ Calls per hour: 100,000
        └─ Per-second derived: 16.67
     
 85  Exact Online API:
        ├─ Calls per minute: 60
        ├─ Calls per hour: 5,000
        └─ Per-second derived: 1.0
     
 90  IMPLEMENTATION:
        self._rate_limit_lock = threading.Lock()
        
        with self._rate_limit_lock:
            time_since_last = current_time - self._last_api_call_time
 95         if time_since_last < min_interval:
                sleep_time = min_interval - time_since_last
                time.sleep(sleep_time)
            self._last_api_call_time = time.time()
     
100  